import { describe, it, expect, beforeAll, afterAll, jest } from '@jest/globals';
import { config } from 'dotenv';
import { GitHubUtils } from '../../src/agents/shared/github-utils.js';
import { InitializerAgent } from '../../src/agents/initializer/initializer-agent.js';
import { DeveloperAgent } from '../../src/agents/developer/developer-agent.js';

// Load environment variables
config();

describe('GitHub Workflow End-to-End Test', () => {
  let githubUtils: GitHubUtils;
  let testIssueNumber: number;
  let testPullRequestNumber: number;
  let githubToken: string;
  let owner: string;
  let repo: string;

  beforeAll(async () => {
    // Check for required environment variables
    githubToken = process.env.GITHUB_TOKEN || '';
    owner = process.env.GITHUB_OWNER || '';
    repo = process.env.GITHUB_REPO || '';

    if (!githubToken || !owner || !repo) {
      throw new Error(
        'Missing required environment variables. Please set GITHUB_TOKEN, GITHUB_OWNER, and GITHUB_REPO in .env file'
      );
    }

    githubUtils = new GitHubUtils(githubToken, owner, repo);
  });

  afterAll(async () => {
    // Cleanup: Close test issue and PR if they were created
    if (testIssueNumber && githubUtils) {
      try {
        await githubUtils.createIssueComment(
          testIssueNumber,
          'ðŸ§¹ Cleaning up end-to-end test. This issue can be closed.'
        );
      } catch (error) {
        console.warn('Failed to cleanup test issue:', error);
      }
    }
  });

  it('should complete full GitHub workflow: issue creation â†’ agent processing â†’ PR creation', async () => {
    // Step 1: Create a test GitHub issue with a basic instruction
    const testInstruction = 'Create a simple utility function that adds two numbers';
    const issueTitle = `[E2E Test] ${testInstruction}`;
    const issueBody = `
## Test Specification

This is an end-to-end test issue created automatically.

### Requirements:
- Create a new utility function called \`addNumbers\`
- Function should accept two number parameters
- Function should return the sum of the two numbers
- Add basic JSDoc documentation
- Include unit tests

### Expected Outcome:
A pull request with the implementation should be created automatically.

---
ðŸ§ª Generated by end-to-end test at ${new Date().toISOString()}
    `.trim();

    // Create issue using Octokit directly since GitHubUtils doesn't have createIssue method
    const { Octokit } = await import('@octokit/rest');
    const octokit = new Octokit({ auth: githubToken });
    
    const createIssueResponse = await octokit.issues.create({
      owner,
      repo,
      title: issueTitle,
      body: issueBody,
      labels: ['agent:developer', 'test:e2e']
    });

    testIssueNumber = createIssueResponse.data.number;
    
    expect(testIssueNumber).toBeGreaterThan(0);
    console.log(`âœ… Created test issue #${testIssueNumber}: ${issueTitle}`);

    // Step 2: Wait a moment to ensure issue is created
    await new Promise(resolve => setTimeout(resolve, 1000));

    // Step 3: Verify issue was created with correct labels
    const createdIssue = await githubUtils.getIssue(testIssueNumber);
    expect(createdIssue.number).toBe(testIssueNumber);
    expect(createdIssue.title).toBe(issueTitle);
    expect(githubUtils.hasLabel(createdIssue, 'agent:developer')).toBe(true);

    // Step 4: Create and run InitializerAgent to detect the issue
    const initializerAgent = new InitializerAgent({
      githubToken,
      owner,
      repo,
      pollIntervalMs: 1000, // Fast polling for testing
    });

    // Mock the DeveloperAgent spawning to track when it's called
    let developerAgentSpawned = false;
    let developerAgentIssueNumber: number;

    // Override the spawnDeveloperAgent method to track calls
    const originalSpawnMethod = (initializerAgent as any).spawnDeveloperAgent;
    (initializerAgent as any).spawnDeveloperAgent = async function(issue: any) {
      developerAgentSpawned = true;
      developerAgentIssueNumber = issue.number;
      
      // Call the original method
      await originalSpawnMethod.call(this, issue);
    };

    // Start the initializer agent
    await initializerAgent.start();

    // Wait for the agent to detect and process the issue
    await new Promise(resolve => setTimeout(resolve, 3000));

    // Stop the initializer agent
    await initializerAgent.stop();

    // Step 5: Verify InitializerAgent detected and spawned DeveloperAgent
    expect(developerAgentSpawned).toBe(true);
    expect(developerAgentIssueNumber).toBe(testIssueNumber);
    console.log('âœ… InitializerAgent successfully detected and processed the issue');

    // Step 6: Verify that a comment was added to the issue by the InitializerAgent
    await new Promise(resolve => setTimeout(resolve, 1000));
    
    // Get issue comments to verify agent interaction
    const commentsResponse = await octokit.issues.listComments({
      owner,
      repo,
      issue_number: testIssueNumber
    });

    const agentComment = commentsResponse.data.find(comment =>
      comment.body?.includes('Developer agent has been assigned')
    );
    expect(agentComment).toBeDefined();
    console.log('âœ… InitializerAgent successfully added assignment comment');

    // Step 7: Create and run DeveloperAgent directly to complete the workflow
    const developerAgent = new DeveloperAgent({
      githubToken,
      owner,
      repo,
      issueNumber: testIssueNumber,
    });

    // Mock the actual implementation and PR creation for testing
    let pullRequestCreated = false;
    let pullRequestTitle: string;
    let pullRequestBranch: string;

    // Override the createPullRequest method to track calls
    const originalCreatePR = (developerAgent as any).createPullRequest;
    (developerAgent as any).createPullRequest = async function(branchName: string, plan: any) {
      pullRequestCreated = true;
      pullRequestTitle = `Implement: ${createdIssue.title}`;
      pullRequestBranch = branchName;
      
      // For testing, create a simple comment instead of actual PR
      await githubUtils.createIssueComment(
        testIssueNumber,
        `âœ… [MOCK] Pull request would be created:\n- Title: ${pullRequestTitle}\n- Branch: ${pullRequestBranch}\n- Implementation completed successfully!`
      );
      
      console.log(`âœ… DeveloperAgent completed implementation for issue #${testIssueNumber}`);
    };

    // Override branch creation and implementation for testing
    (developerAgent as any).createImplementationBranch = async function() {
      return `agent/developer-issue-${testIssueNumber}`;
    };

    (developerAgent as any).implementFeatures = async function(plan: any) {
      console.log('âœ… DeveloperAgent implementing features...');
      // Simulate implementation work
      await new Promise(resolve => setTimeout(resolve, 500));
    };

    // Start the developer agent
    await developerAgent.start();

    // Wait for the agent to complete its work
    await new Promise(resolve => setTimeout(resolve, 2000));

    // Stop the developer agent
    await developerAgent.stop();

    // Step 8: Verify DeveloperAgent completed the workflow
    expect(pullRequestCreated).toBe(true);
    expect(pullRequestTitle).toContain('Implement:');
    expect(pullRequestBranch).toContain(`agent/developer-issue-${testIssueNumber}`);
    console.log('âœ… DeveloperAgent successfully completed the implementation workflow');

    // Step 9: Verify final issue comments
    await new Promise(resolve => setTimeout(resolve, 1000));
    
    const finalCommentsResponse = await octokit.issues.listComments({
      owner,
      repo,
      issue_number: testIssueNumber
    });

    const implementationComment = finalCommentsResponse.data.find(comment =>
      comment.body?.includes('Implementation completed') || comment.body?.includes('MOCK] Pull request would be created')
    );
    expect(implementationComment).toBeDefined();
    console.log('âœ… DeveloperAgent successfully added completion comment');

    // Final verification
    console.log(`ðŸŽ‰ End-to-end test completed successfully!`);
    console.log(`   - Issue #${testIssueNumber} was created with proper labels`);
    console.log(`   - InitializerAgent detected and assigned the issue`);
    console.log(`   - DeveloperAgent processed the issue and completed implementation`);
    console.log(`   - Workflow completed as expected`);
    
  }, 30000); // 30 second timeout for the full workflow

  it('should handle agent:developer label filtering correctly', async () => {
    // Create an issue without the agent:developer label
    const { Octokit } = await import('@octokit/rest');
    const octokit = new Octokit({ auth: githubToken });
    
    const nonAgentIssue = await octokit.issues.create({
      owner,
      repo,
      title: '[E2E Test] Non-agent issue - should be ignored',
      body: 'This issue should not be processed by agents',
      labels: ['bug', 'test:e2e']
    });

    const nonAgentIssueNumber = nonAgentIssue.data.number;

    try {
      // Create initializer agent
      const initializerAgent = new InitializerAgent({
        githubToken,
        owner,
        repo,
        pollIntervalMs: 1000,
      });

      // Track if any agent was spawned
      let agentSpawned = false;
      (initializerAgent as any).spawnDeveloperAgent = async function() {
        agentSpawned = true;
      };

      // Start and run for a short time
      await initializerAgent.start();
      await new Promise(resolve => setTimeout(resolve, 2000));
      await initializerAgent.stop();

      // Verify no agent was spawned for non-agent issue
      expect(agentSpawned).toBe(false);
      console.log('âœ… InitializerAgent correctly ignored non-agent issue');

    } finally {
      // Cleanup: Close the non-agent issue
      await octokit.issues.update({
        owner,
        repo,
        issue_number: nonAgentIssueNumber,
        state: 'closed'
      });
    }
  });
});